log.Println("#### [1/5] SCP k8s_setup Script ####")
	log.Println("SCP task now processing..")
	var err error
	cfg := &src.Config{}
	configDir := src.DEFAULT_CONFIG_DIR_PATH
	if string(configDir[len(configDir)-1]) == "/" {
		configDir = configDir[:len(configDir)-1]
	}
	// Read Config file. ${pwd}/config.yaml
	buf, err := ioutil.ReadFile(fmt.Sprintf("%s/config.yaml", configDir))
	if err != nil {
		log.Fatal(err)
		return
	}
	err = yaml.Unmarshal(buf, cfg)
	if err != nil {
		log.Fatalf("Unmarshal: %v", err)
		return
	}
	// Get Base Path. ex) baseDir := "/home1/irteamsu"
	baseDir := src.SshCMDToGetOutput(fmt.Sprintf("ssh %s:%s pwd", cfg.User, cfg.Masters[0]))
	allNodes := append(cfg.Masters, cfg.Workers...)

	// SCP Agent to nodes & Run Agent(in Parallel) by using Go-routine
	stepIsOK := true
	var wg sync.WaitGroup
	src.SshCMDToAllNodesByChannel(&wg, allNodes,
		fmt.Sprintf("scp %s %s", fmt.Sprintf("%s/k8s_setup.sh", configDir), fmt.Sprintf("%s@nodeip:%s", cfg.User, baseDir)), &stepIsOK)
	if stepIsOK {
		log.Println("SCP k8s_setup to all nodes success\n")
	} else {
		log.Fatal("SCP k8s_setup to some node fail")
	}

	log.Println("#### [2/5] Execute Initial Install Script ####")
	log.Println("Executing task now processing..")
	src.SshCMDToAllNodesByChannel(&wg, allNodes,
		fmt.Sprintf("ssh %s sh %s", fmt.Sprintf("%s@nodeip", cfg.User), fmt.Sprintf("%s/%s", baseDir, "k8s_setup.sh")), &stepIsOK)
	if stepIsOK {
		log.Println("Execute k8s_setup Script to all nodes success\n")
	} else {
		log.Fatal("Execute k8s_setup Script to some node fail")
	}

	log.Println("#### [3/5] Kubeadm Init Start  ####")
	log.Println("kubeadm init from [", cfg.Masters[0], "] start..")
	kdmJoinCMD := fmt.Sprintf("ssh %s sudo kubeadm init --kubernetes-version %s --pod-network-cidr %s --upload-certs",
		fmt.Sprintf("%s@%s", cfg.User, cfg.Masters[0]), cfg.K8sVersion, cfg.PodNetworkCidr)
	if cfg.ControlPlaneEndpoint != "" {
		kdmJoinCMD = kdmJoinCMD + " " + fmt.Sprintf("--control-plane-endpoint %s", cfg.ControlPlaneEndpoint)
	}
	kdmJoinCMDStr := src.SshCMDToGetOutput(kdmJoinCMD)
	log.Println("kubeadm init from [", cfg.Masters[0], "] end\n")

	log.Println("#### [4/5] Kubeadm join Start  ####")
	log.Println("kubeadm join Start..")
	kdmMasterJoinCMD, kdmWorkerJoinCMD := src.ParsingKubeadmJoinCMD(strings.Split(kdmJoinCMDStr, "\n"))
	if kdmMasterJoinCMD != "" {
		log.Println("Now Master Nodes Join Start")
		log.Println("Master Join CMD: ", kdmMasterJoinCMD)
		src.SshCMDToAllNodesByChannel(&wg, cfg.Masters[1:], fmt.Sprintf("ssh %s sudo %s",
			fmt.Sprintf("%s@nodeip", cfg.User), kdmMasterJoinCMD), &stepIsOK)
		if stepIsOK {
			log.Println("All Master Join success\n")
		} else {
			log.Println("Some Master Join fail")
		}
	}
	log.Println("Now Worker Nodes Join Start")
	log.Println("Worker Join CMD: ", kdmWorkerJoinCMD)
	src.SshCMDToAllNodesByChannel(&wg, cfg.Workers, fmt.Sprintf("ssh %s sudo %s",
		fmt.Sprintf("%s@nodeip", cfg.User), kdmWorkerJoinCMD), &stepIsOK)
	if stepIsOK {
		log.Println("All Worker Join success")
	} else {
		log.Println("Some Worker Join fail")
	}
	log.Println("Kubeadm join end\n")

	log.Println("#### [5/5] run config/*_bash_script.sh  ####")
	log.Println("bash script from [", cfg.Masters[0], "] execute..")
	files, _ := ioutil.ReadDir(configDir)
	filesCnt := len(files)
	log.Println(fmt.Sprintf("Total extra script count: %d.", filesCnt))
	err = exec.Command("scp", "-r", configDir,
		fmt.Sprintf("%s@%s:%s", cfg.User, cfg.Masters[0], baseDir)).Run()
	if err != nil {
		log.Println("fail to scp config directory. err: ", err.Error())
	}
	cache := strings.Split(configDir, "/")
	directoryName := cache[len(cache)-1]
	for i := 0; i < filesCnt; i++ {
		err := exec.Command("ssh", fmt.Sprintf("%s@%s", cfg.User, cfg.Masters[0]),
			"sh", fmt.Sprintf("%s/%s/%d*", baseDir, directoryName, i+1)).Run()
		if err != nil {
			log.Println(fmt.Sprintf("%d_{script} excute fail. ", i+1), "err: ", err.Error())
		} else {
			log.Println(fmt.Sprintf("%d_{script} excute sucess", i+1))
		}
	}
	log.Println("bash script from [", cfg.Masters[0], "] complete")
	log.Println("kubernetes clustering finish!")